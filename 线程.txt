1.线程

1.1 线程概念
	Linux下，线程是cpu调度的基本单位，而进程是资源分配的基本单位，进程是一个线程组。

1.2 线程的独有与共享
	* 独有：栈、寄存器、线程标识、优先级、errno、信号屏蔽字
	* 共享：虚拟地址空间(代码段+数据段)、文件描述符表、信号处理方式、当前工作路径、用户ID、组ID

2.线程控制：线程创建 / 线程退出 / 线程等待 / 线程分离    
	* 操作系统并没有给用户直接提供创建一个线程的接口，因此需要封装一套线程库，用于线程控制 -> 用户态线程；
	* 编译链接时加 -lpthread；
	* 线程之间无父子之分，有兄弟。

	gcc -std=c99 cond.c -o cond -lpthread
	
2.1 线程创建

	int pthread_create(pthread_t *tid, pthread_attr_t *attr, void *(*start_routine)(void*), void *arg); 
 	tid:返回线程ID    
	attr:设置线程的属性，attr为NULL表示使用默认属性 ，平常置空    
	start_routine:是个函数地址，线程启动后要执行的函数     
	arg:传给线程启动函数的参数 
	返回值：成功返回0、失败返回错误码

2.2 线程终止
	* 线程将自己的入口函数运行完毕return退出；（main中return退出的是进程）(自己)
	* void pthred_exit(void *retval)， 退出调用线程，谁调用谁退出；(自己)
	* int pthred_cancel(pthread_t tid)，取消一个指定线程。(别人)

2.3 线程等待
	* 等待一个指定的线程退出，获取这个退出线程的返回值，并且回收资源。

【为什么要线程等待】
	* 已经退出的线程，其空间没有被释放，仍然在进程的地址空间内；
	* 创建新的线程不会复用刚才退出线程的地址空间。

	* 一个线程创建出来，默认在退出时是不会释放所有资源的，这是因为线程有一个属性--joinable，处于joinable状态的线程，退出后不会自动释放资源，需要被等待。

2.4 线程分离
	* 将线程的属性从joinable设置成detach，表示分离一个线程；被分离，处于detach属性的线程退出后，则会自动释放所有资源(被分离的线程没有必要被等待)。

	int pthread_detach(pthread_t, tid);
	* 多个执行流对同一个临界资源进行争抢访问，但不会造成数据二义。

3.线程安全

3.1 概念
	* 多个执行流对同一个临界资源进行争抢访问，但不会造成数据二义。

3.2 实现
	* 同步：通过条件判断实现对临界资源访问的时序合理(不能访问则等待，能够访问则唤醒)；
	* 互斥：同一时间只能由一个执行流能够访问临界资源，实现数据操作安全；
	* 互斥的实现：互斥锁/信号量；
	* 同步的实现：条件变量/信号量；

3.2.1 互斥锁 -> 保护临界资源
	* 通过只有一个0/1的计数器完成互斥，标记两种临界资源的访问状态；
	* 访问临界资源之前先访问互斥锁，来判断当前是否能够访问临界资源。（计数器的操作必须是原子操作—使用一个交换指令完成寄存器与内存之间的数据交换）
	* 加锁：1 -> 0
	* 解锁：0 -> 1

		死锁产生必要条件：
		* 互斥条件：锁同一时间只有一个线程能够获取；
		* 不可剥夺条件：我加的锁只能我解锁；
		* 请求与保持条件：拿着A锁请求B，若请求不到，则一直保持A的所有不释放；
		* 环路等待条件。

	预防：破坏必要条件；
	避免：银行家算法；

3.2.2 条件变量
	* 通过用户提供线程等待与唤醒功能的接口实现同步，但是什么时候该等待、什么该唤醒需要用户自己进行控制，

		* 条件变量需要搭配互斥锁使用——用户用于判断是否等待的条件是一个临界资源，需要加锁保护
		* pthread_cond_wait中集合了三步操作：解锁->休眠->加锁
		* 用户条件判断需要使用循环语句
		* 不同的角色需要使用不同的条件变量进行等待唤醒，不同的角色不能等待在同一个队列


3.3.3 信号量实现同步
	* 计数的条件判断+等待与唤醒接口；
	* 通过自身的计数器进行资源计数，对临界资源访问之前先访问信号量，通过计数判断是否有资源能够访问：

		* 若不能访问计数<=0：等待，并且计数-1；
		* 若可以访问计数>0：计数-1，直接访问；
		* 其它条件促使条件满足后，则判断：

			* 若计数>0，计数+1；
			* 若计数<0，则唤醒一个等待队列上的线程，并计数+1；
