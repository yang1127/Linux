# Linux
进程概念：冯诺依曼体系结构/操作系统管理/进程概念/进程状态/优先级/环境变量/程序地址空间

1.冯诺依曼体系结构：现代计算机的硬件体系结构

	* 五大硬件单元：输入设备(键盘)/输出设备()显示器/存储器(内存条)/运算器/控制器(中央处理器cpu)
	* 硬件结构决定软件行为/所有设备都是围绕存储器工作的

2.操作系统：内核+应用
	* 定位：搞管理的软件--管理计算机上软硬件资源
	* 管理：先描述、再组织
	* 库函数与系统调用接口的关系：库函数封装了系统调用接口

3.进程概念
	* 什么是进程？ ->   运行中的程序   ->  PCB
	* 进程：从操作系统角度分析，进程是一个运行中程序描述 —— PCB(进程控制块)，每一个程序都有
                     Linux下这个pcb实际上是一个结构体 struct  task_struct{...}

【进程如何描述一个运行中的程序】
        内存指针，程序计数器(保存下一步执行的指令)，上下文数据(保存程序上一次正在处理的数据)，标识符PID(进程id)，状态，优先级，记账信息(一个进程在cpu中运行的时间)，IO信息

        CPU的分时机制：每个程序在cpu上运行都有一个时间片  -> Linux：多任务操作系统
        时间片：程序在cpu运行的这段时间，运行完毕则调度切换

【如何查看进程】

ps -ef (查看所有进程信息) / aux (信息更详细)  ->  tty:终端信息
pid_t getpid(void) //获取调用进程的ID

4.进程状态
        运行、就绪、阻塞

【Linux下的进程状态】
        运行状态R / 可中断休眠状态S / 不可中断休眠状态D / 停止状态T / 死亡状态X / 追踪状态t / 僵尸状态Z

【僵尸进程】
	* 僵尸状态：进程已经退出，但是资源没有完全释放
	* 僵尸进程：处于僵尸状态的进程
	* 僵尸进程的产生：子进程先于父进程退出，为了保存退出的原因，资源并没有完全被释放。因此在子进程退出时，操作系统会通知父进程，让父进程获取子进程的退出原因，然后释放子进程所有资源。如果父进程当前并没有关注子进程退出状态，则子进程成为僵尸进程
	* 僵尸进程的危害：资源泄露
	* 僵尸进程的避免：进程等待
	* 僵尸进程的处理：退出父进程


 1 //僵尸进程
 2 //
 3 #include<stdio.h>
 4 #include<unistd.h>
 5 #include<stdlib.h>
 6
 7 int gval = 100;
 8 int main()
 9 {
10         int ppid = getpid();
11         //exit(0); //退出、则不会进行下一步操作
12         int pid = fork();
13         //fork 创建子进程之后，父子进程代码共享，数据独有
14         if (pid > 0){
15                 //parent
16                 gval = 10;
17         }else if (pid == 0){
18                 //child
19                 sleep(3);
20                 exit(0); //子进程退出则为僵尸进程
21         }
22
23         printf("--- 你好漂亮！---%d, pid=%d-ppid:%d\n", gval, getpid(), ppid); //getpid():当前调用进程id、ppid:父进程，打印出来相同为父进程，不同为子进>    程
24         while(1){
25                 sleep(1);
26         }
27
28         return 0;
29 }
 
进程创建：pid_t fork(void)
    通过复制调用进程创建一个子进程，子进程因为拷贝了父进程pcb里边的很多数据因此与父进程内存指针以及程序计数器都相同，所以运行的代码以及运行的位置都一样

返回值有三种：通过返回值进行代码分流
    -1：创建子进程失败
    ==0：对于子进程，返回值时0
    >0：对于父进程，返回值是子进程的pid


【孤儿进程】
        孤儿进程：父进程先于子进程退出，子进程成为孤儿进程，运行在后台，父进程成为1号进程(init 进程)（孤儿进程退出不会成为僵尸进程）


【守护进程/精灵进程】
        守护进程/精灵进程：特殊的孤儿进程(在孤儿进程的基础上，脱离终端脱离登陆会话)（通常运行在后台，默默工作，不希望收到终端会话的影响）以d结尾

5.进程优先级：决定进程cpu资源的优先分配权
        数字越小，优先级越高
        程序分类：CPU密集/IO密集
        进程分类：批处理/交互式

        renice -n 19 -p pid //设置进程优先级 将某进程(pid)的nice值设置为19  NI+PRI为最终优先级
        sudo nice -n -20 ./zombie
		
6.环境变量：存放系统运行环境参数的变量

6.1 命令env //查看所有环境变量
    echo $PATH //查看PATH的环境变量、查看指定的环境变量
    set //产看所有变量包括环境变量
    export //设置环境变量
    unset  //删除一个环境变量 
	
6.2 目的
	1. 让系统运行环境参数配置起来更加灵活
	2. 环境变量具有全局特性

6.3 代码

获取环境变量：
char *getenv(const char *name);
main(int argc, char *argv[], char *env[]);
extern char **environ; //直接使用库中


  1 #include<stdio.h>
  2 #include<stdlib.h>
  3
  4 //argv[] 存放程序运行参数
  5 //argc[] 程序运行参数的个数
  6 int main(int argc, char *argv[], char *env[])
  7 { 
  8        extern char **environ; //方法二：二级指针  声明一个指针
  9        int i;
10         for (i = 0; environ[i] != NULL; i++){
11                 printf("environ[%d] = [%s]\n", i, environ[i]);
12         }
13
14         /*int i;  方法一：参数法
15         for (i = 0; i < argc; i++){
16                 printf("argv[%d] = %s\n", i, argv[i]);
17         }
18         for (i = 0; env[i] != NULL; i++){
19                 printf("env[%d] = [%s]\n", i, env[i]);
20         }
21         */
22
23         //char *getenv(const char *name)
24         //通过环境变量名获取内容
25         char *ptr = getenv("MYTEST");
26         if (ptr == NULL){
27                 printf("have no MYTEST\n");
28                 return -1;
29         }
30         printf("MYTEST=%s\n", ptr);
31         return 0;
32 }


7.程序地址空间
 【虚拟地址空间】
	* 是操作系统为进程所描述的一个假的地址空间；目的是为了让进程认为自己拥有一块连续的线性的完整的地址空间；但实际上一个进程使用的内存并非连续存储，而是通过页表映射虚拟地址与物理地址之间关系；让进程通过页表获取物理地址，进而实现数据的离散式存储

作用：
	1. 提高内存利用率：物理内存的离散存储；
	2. 保证了进程独立性：每个进程只能访问自己虚拟地址映射的物理内存；
	3. 页表可以进行内存访问控制：页表可以对每个虚拟地址进行权限标记

【内存管理】
	* 分段式：对程序比较友好，但利用率不高
	* 分页式：提高内存的利用率
	* 段页式：目前采用的方案  

【物理地址的计算方法】
	* 虚拟地址 / 页面大小 = 页号   通过页表得到块号  -> 分页式计算
	* 块号*块大小 + 页内偏移 （虚拟地址%页面大小）

